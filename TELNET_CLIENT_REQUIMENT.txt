요약: Telnet 클라이언트는 RFC 854의 IAC/명령 처리와 RFC 855의 옵션 협상 규칙을 기본으로, RFC 858(SGA), RFC 1184(LINEMODE), RFC 1091(TERMINAL-TYPE)을 각각 시나리오에 맞게 DO/WILL/DONT/WONT와 SB/SE 서브협상을 구현해야 한다. 각 옵션은 양방향·독립적으로 협상되며, 데이터 스트림에서는 IAC=0xFF 이스케이프 규칙을 항상 준수해야 한다.[^1][^2][^3][^4][^5]

### 기본 IAC/명령 처리 (RFC 854)

- 클라이언트는 IAC(255)로 시작하는 명령을 파싱하고, SE(240), SB(250), WILL/WON’T/DO/DON’T(251–254), GA(249), IP/AO/AYT/EC/EL/BRK/DM 등을 규격대로 처리해야 한다.[^1]
- 데이터 안의 0xFF는 IAC IAC로 이스케이프되어 전송되므로, 수신 시 IAC IAC는 단일 0xFF 데이터 바이트로 복원해야 한다.[^1]
- Synch/DM(Data Mark)은 TCP Urgent와 함께 오며, 서브협상은 IAC SB … IAC SE로 경계가 표시되니 중첩 없이 정확히 프레이밍해야 한다.[^1]


### 옵션 협상 원칙 (RFC 855)

- 모든 옵션은 DO/DON’T(상대에게 수행 요청/중지 요구), WILL/WON’T(자신이 수행 의사/거부)만으로 협상하며, 각 방향은 독립적이다.[^2]
- 구현은 옵션을 자유롭게 실험·도입·폐기할 수 있으나, 문서화된 코드/의미를 따르고 미지원 옵션에는 즉시 부정 응답(WON’T/DON’T)을 보내야 한다.[^2]


### SGA 억제 (RFC 858)

- SGA(코드 3)는 GO AHEAD 신호를 생략하기 위한 옵션으로, WILL/DO SGA를 협상하면 해당 방향에서 GA 전송을 중지한다.[^5]
- 문자 단위 에코 환경을 만들 때는 SGA와 ECHO를 함께 맞추는 것이 일반적이며, SGA가 켜진 방향은 지연 없이 문자 전송을 시도하는 것이 권장된다.[^5]


### LINEMODE (RFC 1184)

- 서버가 DO LINEMODE를 제안하면, 클라이언트는 지원 시 WILL LINEMODE로 응답하고 이후 SB LINEMODE 하위 옵션(MODE, FORWARDMASK, SLC)을 협상한다.[^3]
- MODE 서브옵션의 EDIT/TRAPSIG/MODE_ACK/SOFT_TAB/LIT_ECHO 비트를 해석해야 하며, 수신 MODE가 현재와 다르면 ACK 비트로 동기화하는 규칙을 따른다.[^3]
- FORWARDMASK는 어떤 문자를 입력 버퍼에서 즉시 원격으로 보낼지 결정하는 32옥텟 비트마스크이며, IAC 값은 이중 IAC로 전송해야 한다.[^3]
- SLC(Set Local Characters)는 EC/EL 등 로컬 편집 키를 3바이트 트리플 목록으로 교환하며, 수준(SLC_DEFAULT/…/SLC_NOSUPPORT)에 따라 변경 가능성을 표시한다.[^3]


### TERMINAL-TYPE (RFC 1091)

- 서버가 DO TERMINAL-TYPE을 보낸 뒤, 클라이언트는 WILL로 동의하고 서버 요청(IAC SB TERMINAL-TYPE SEND IAC SE)에만 응답으로 IS <type>을 보낸다.[^4]
- 터미널 유형 문자열은 NVT ASCII이며 대소문자 무시, 클라이언트는 보낸 타입에 맞춰 에뮬레이션 모드를 전환할 수 있다(필요 시 BINARY 등 선행 요구 충족).[^4]


### 시나리오별 구현 체크리스트

- 연결 직후 기본 협상
    - 미지원 옵션의 DO/WILL에는 즉시 WON’T/DON’T로 부정 응답하고, 지원하는 SGA/ECHO/TERMINAL-TYPE/LINEMODE 등에만 긍정 응답한다.[^2][^1]
    - 데이터 경로는 항상 0xFF 이스케이프 규칙(IAC IAC)을 적용하고, SB/SE 프레이밍 오류가 없도록 상태 머신으로 처리한다.[^1]
- 문자 단위(character-at-a-time) 환경 구성
    - 서버가 WILL SGA → 클라이언트 DO SGA로 수락하며, 에코 정책(ECHO)은 한쪽만 수행되도록 상호 일치시킨다.[^5]
    - 데이터는 사용자의 키 입력마다 전송되어야 하며, GA 수신 시 NOP 취급할 수 있으나 SGA가 켜진 상태에서는 GA를 보내지 않는 것이 정상이다.[^5]
- 라인 모드(line-at-a-time) 활성 및 편집
    - 서버 DO LINEMODE → 클라이언트 WILL LINEMODE 후, SB LINEMODE MODE EDIT|TRAPSIG 등으로 로컬 편집/신호 트래핑을 설정한다. [^3]
    - 라인 커밋은 FORWARDMASK 또는 Enter/CRLF 등 정책으로 결정되며, 클라이언트는 MODE/ACK 절차로 서버와 모드 동기화를 유지한다.[^3]
- 라인 모드 → 문자 모드 전환
    - 서버가 SB LINEMODE MODE 0을 보내면 EDIT 비트가 내려가고 클라이언트는 문자 단위 전송으로 전환해야 하며, 필요한 경우 DONT LINEMODE로 완전히 해제한다.[^3]
    - 전환 시 중복 에코를 피하려면 ECHO/SGA 협상 상태를 재점검하여 한쪽만 에코하도록 정리한다.[^5]
- 터미널 유형 교환
    - 서버 DO TERMINAL-TYPE → 클라이언트 WILL → 서버 SB TERMINAL-TYPE SEND → 클라이언트 SB TERMINAL-TYPE IS "VT100" 등으로 응답한다.[^4]
    - 클라이언트는 자발적(IS) 전송을 하지 말고, 요청(SEND)에만 응답하며 타입 문자열은 표준 명칭을 사용한다.[^4]


### 방어적 동작과 기본값

- 기본값은 WON’T/DON’T이며, 협상되지 않은 옵션의 동작은 NVT 규칙(예: GA 사용)으로 돌아가야 한다.[^5]
- 옵션은 각 방향이 독립이므로, 한 방향에서 DO/WILL이 수락되었다고 반대 방향도 자동 허용되는 것은 아니다.[^2]


### 구현 팁

- 협상은 상태 변화 시에만 재개하고, 매 데이터 전송마다 SB/SE를 재부착하지 않는다(초기/변경 시에만 수행).[^3]
- 텔넷 파서는 IAC 명령과 데이터 스트림을 분리하는 상태 머신으로 구현하고, SB의 페이로드는 IAC SE로만 종료됨을 전제로 누적 파싱한다.[^1]


### 예시 시퀀스(헥스)

- 라인 모드 설정(로컬 편집 on): “IAC DO 22; IAC WILL 22; IAC SB 22 01 (MODE=EDIT|TRAPSIG) IAC SE; …” 형태를 처리한다. [^3]
- 문자 모드 전환: “IAC SB 22 01 00 IAC SE”로 MODE 0을 적용하거나 “IAC DONT 22”로 LINEMODE를 비활성화한다.[^3]
- SGA 양방향: “IAC WILL 03” ↔ “IAC DO 03”를 각 방향에 대해 협상한다.[^5]

이상의 요구사항을 만족하면, 클라이언트는 RFC 854/855의 기본 규범 위에 SGA(858), LINEMODE(1184), TERMINAL-TYPE(1091) 시나리오를 정확히 처리할 수 있다.

================================추가내용

다음 두 문서는 Telnet 클라이언트가 구현해야 할 핵심을 서로 다른 영역에서 정의한다. RFC 856은 8비트 바이너리 전송 규칙과 협상 절차를, RFC 1091은 터미널 유형 교환 절차를 규정한다.[^1][^2]

### RFC 856: Binary Transmission

- 옵션/코드: TRANSMIT-BINARY(코드 0)로, 각 방향을 독립적으로 협상한다(IAC WILL/DO/WON’T/DON’T 0).[^1]
- 상태 규칙: 바이너리 모드는 “한쪽의 요청 + 상대의 수락”이 성립해야 활성이며, 기본값은 WON’T/DON’T(비바이너리)이다.[^1]
- 데이터 규칙: 바이너리 모드에서도 IAC(0xFF)는 항상 이스케이프(IAC IAC)해야 하며, 수신 측은 IAC IAC를 단일 0xFF 데이터로 복원한다(그 외 바이트는 8비트 그대로).[^1]
- 모드 해제: 바이너리 모드 진입 전에는 WON’T/DON’T가 “현재 인코딩 유지” 의미지만, 일단 바이너리 모드에 들어간 뒤 WON’T/DON’T가 오면 NVT ASCII로 되돌아간다(스택 복원 회피 규칙).[^1]
- 상호작용: 다른 옵션(ECHO, SGA, TERMINAL-TYPE 등)과 병행 협상이 가능하며, 필요 시 UI/단말 기능과의 정합을 고려한다.[^1]

클라이언트 구현 체크리스트:

- 수신: IAC WILL/DO/WON’T/DON’T 0 처리, 양방향 상태를 별도 추적, 루프 방지 규칙 적용.[^1]
- 송신: 원하는 방향에 대해 WILL(내가 보냄)/DO(상대가 보냄)를 적시에 전송, 거부 시 WON’T/DON’T로 응답.[^1]
- 데이터 경로: 송수신 모두 0xFF 이중화/IAC 파서 일관 유지, 바이너리 해제 시 NVT ASCII로 회귀.[^1]


### RFC 1091: Terminal-Type

- 역할 구분: 서버가 DO TERMINAL-TYPE을 보내고, 클라이언트는 WILL로 동의한 뒤 서버의 SEND 요청에만 IS <type>으로 응답한다(자발 전송 금지).[^2]
- 문자열: 타입은 NVT ASCII 문자열이며 대소문자 무시, Assigned Numbers에 등록된 명칭 사용 권장(단 수신측은 임의 명칭도 수용).[^2]
- 다중 타입: 서버가 SEND를 반복하면 클라이언트는 보유한 타입들을 순차 제공할 수 있으며, 서버가 선호 타입을 선택한다.[^3][^2]
- 모드 전환: 타입을 보낼 때 클라이언트는 해당 터미널 에뮬레이션으로 즉시 전환할 준비가 되어 있어야 하며, 전제 조건(예: BINARY 협상)이 필요한 경우 그 후에 전환한다.[^2]

클라이언트 구현 체크리스트:

- 협상: DO 수신 시 WILL, DON’T 수신 시 WON’T로 정리하고, SEND가 오기 전에는 IS를 보내지 않는다.[^2]
- 타입 제공: 환경 설정에 따른 우선순위 목록을 유지하고, 반복 SEND에 대응해 순환 제공(서버 선택 지원).[^3][^2]
- 호환성: 미지원이면 WON’T TERMINAL-TYPE로 즉시 부정 응답, 지원 시에도 Unknown 타입 수신에 관대한 파싱 유지.[^2]

요약 지침:

- Binary는 데이터 경로의 8비트 투명성과 IAC 이스케이프를 책임지므로, 텍스트 외(UTF-8, 이미지, 3270/EOR 등)에서도 안정 동작을 위해 구현 필수다.[^1]
- Terminal-Type은 서버가 클라이언트 단말 특성에 맞춰 동작하게 하는 메타 협상으로, SEND→IS의 요청-응답 비동기 구조를 정확히 지켜야 한다.[^2]

